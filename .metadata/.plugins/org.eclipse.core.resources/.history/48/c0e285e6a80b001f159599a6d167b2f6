// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package export.actions;

import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.nio.file.Files;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Random;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import com.mendix.core.Core;
import com.mendix.core.CoreException;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;
import export.proxies.ExportObjects;
import export.proxies.ExportedGenericXml;
import export.proxies.GenericXMLExportException;
import export.proxies.GxmlExceptionStatus;
import export.ws.GenericWebServiceCall;
import jflowmain.proxies.GenericXML;
import jflowmain.proxies.Journal;
import jflowmain.util.GenericXMLHelper;
import jflowmain.util.ObjectHelper;
import jflowmain.util.StringHelper;

public class ExportGenericXML extends CustomJavaAction<java.lang.Void>
{
	private java.util.List<IMendixObject> __exportObjects;
	private java.util.List<export.proxies.ExportObjects> exportObjects;
	private java.lang.String Queue;

	public ExportGenericXML(IContext context, java.util.List<IMendixObject> exportObjects, java.lang.String Queue)
	{
		super(context);
		this.__exportObjects = exportObjects;
		this.Queue = Queue;
	}

	@java.lang.Override
	public java.lang.Void executeAction() throws Exception
	{
		this.exportObjects = java.util.Optional.ofNullable(this.__exportObjects)
			.orElse(java.util.Collections.emptyList())
			.stream()
			.map(__exportObjectsElement -> export.proxies.ExportObjects.initialize(getContext(), __exportObjectsElement))
			.collect(java.util.stream.Collectors.toList());

		// BEGIN USER CODE
		final StringBuilder builder = new StringBuilder();
		String export = GXML_EXPORT4SAP;
		writeSoapHeader(builder);
		writeExportHeader(builder);
		int count = 0;
		for (ExportObjects exportObject : this.exportObjects) {
			export = exportObject.getExport();
			try {
				log.debug("Regenerate Gxml" + exportObject.getRegenerateGxml());
				final GenericXML xml = GenericXMLHelper.getXml(
						ObjectHelper.getJournal(getContext(), exportObject.getJournalId()), this.Queue,
						exportObject.getRegenerateGxml());
				if (xml != null) {
					writeProduct(xml, builder);
					count++;
				}
			} catch (CoreException ex) {
				exportObject.setExported(false);
				exportObject.setExportDate(null);
				Journal journal = ObjectHelper.getJournal(getContext(), exportObject.getJournalId());
				if (ObjectHelper.isExceptionPresent(journal) == false) {
					log.info("Start creating GxmlCoreException object for journal : " + exportObject.getJournalId());
					GenericXMLExportException gee = new GenericXMLExportException(getContext());
					gee.setJournal_ID(Integer.parseInt(exportObject.getJournalId()));
					gee.setCoreException(ex.getMessage());
					gee.setDetailedException(ex.fillInStackTrace().toString());
					gee.commit();
					log.info("End creating GxmlCoreException object for journal : " + exportObject.getJournalId());
				}
			} catch (Exception ex) {
				exportObject.setExported(false);
				exportObject.setExportDate(null);
				Journal journal = ObjectHelper.getJournal(getContext(), exportObject.getJournalId());
				if (ObjectHelper.isExceptionPresent(journal) == false) {
					log.info("Start creating GxmlException object for journal : " + exportObject.getJournalId());
					GenericXMLExportException gee = new GenericXMLExportException(getContext());
					gee.setJournal_ID(Integer.parseInt(exportObject.getJournalId()));
					gee.setDetailedException(ex.fillInStackTrace().toString());
					gee.setStatus(GxmlExceptionStatus.Inprogress);
					gee.commit();
					log.info("End creating GxmlException object for journal : " + exportObject.getJournalId());
				}
			}
		}
		writeSoapFooter(builder);
		// log.debug(builder.toString());
		if (count > 0) {
			// write the content into xml file
			final File xmlFile = getFile();
			log.info("Filename: " + xmlFile.getName());
			try (BufferedWriter bw = new BufferedWriter(new FileWriter(xmlFile))) {
				bw.write(builder.toString());
				bw.flush();
			} catch (IOException e) {
				log.error("Error: " + e.getMessage());
				throw new CoreException("Error in ExportGenericXML: " + e.getMessage());
			}
			/** Send to PI */
			log.info("Endpoint: " + (export.equalsIgnoreCase(GXML_EXPORT4SAP)
					? Core.getConfiguration().getConstantValue(ENDPOINT_PATH).toString()
					: Core.getConfiguration().getConstantValue(MIGRATION_ENDPOINT_PATH).toString()));
			log.info("User: " + (export.equalsIgnoreCase(GXML_EXPORT4SAP)
					? Core.getConfiguration().getConstantValue(USER_PATH).toString()
					: Core.getConfiguration().getConstantValue(MIGRATION_USER_PATH).toString()));
			log.info("Password: " + (export.equalsIgnoreCase(GXML_EXPORT4SAP)
					? Core.getConfiguration().getConstantValue(PW_PATH).toString()
					: Core.getConfiguration().getConstantValue(MIGRATION_PW_PATH).toString()));

			GenericWebServiceCall.webServiceCall(xmlFile.getAbsolutePath(),
					export.equalsIgnoreCase(GXML_EXPORT4SAP)
							? Core.getConfiguration().getConstantValue(USER_PATH).toString()
							: Core.getConfiguration().getConstantValue(MIGRATION_USER_PATH).toString(),
					export.equalsIgnoreCase(GXML_EXPORT4SAP)
							? Core.getConfiguration().getConstantValue(PW_PATH).toString()
							: Core.getConfiguration().getConstantValue(MIGRATION_PW_PATH).toString(),
					export.equalsIgnoreCase(GXML_EXPORT4SAP)
							? Core.getConfiguration().getConstantValue(ENDPOINT_PATH).toString()
							: Core.getConfiguration().getConstantValue(MIGRATION_ENDPOINT_PATH).toString());
			saveGenericXml(builder, xmlFile);
			Files.delete(xmlFile.toPath());
		}
		log.info("End Export generic xml");
		return null;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "ExportGenericXML";
	}

	// BEGIN EXTRA CODE
	private void build(final StringBuilder builder, final String line) {
		builder.append(line + "\n");
	}

	private String nodeToString(Node node) throws CoreException {
		try {
			final StringWriter sw = new StringWriter();
			final Transformer t = TransformerFactory.newInstance().newTransformer();
			t.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
			t.setOutputProperty(OutputKeys.INDENT, "yes");
			t.transform(new DOMSource(node), new StreamResult(sw));
			return sw.toString();
		} catch (final TransformerException ex) {
			log.error("Error in nodeToString: " + ex.getMessage());
			throw new CoreException(ex.getMessage());
		}
	}

	private void writeSoapHeader(final StringBuilder builder) {
		build(builder, "<?xml version=" + QUOTE + "1.0" + QUOTE + " encoding=" + QUOTE + "UTF-8" + QUOTE + "?>");
		build(builder, "<soapenv:Envelope xmlns:soapenv=" + QUOTE + SCHEMA + QUOTE + ">");
		build(builder, "<soapenv:Body>");
	}

	private void writeExportHeader(final StringBuilder builder) {
		build(builder, "<ns2:JFlowExport xmlns:xsi=" + QUOTE + "http://www.w3.org/2001/XMLSchema-instance" + QUOTE
				+ " xmlns:ns2=" + QUOTE + "http://springer.com/xi/JFLOW/PRODUCTS" + QUOTE + " xsi:schemaLocation="
				+ QUOTE
				+ "http://springer.com/xi/JFLOW/PRODUCTS http://devel.springer.de/GXML4J/GenericXML4Journals_v1_54.xsd"
				+ QUOTE + ">");
		build(builder,
				"<ExportInfo ExportDate=" + QUOTE + exportDate + QUOTE + " Repository=" + QUOTE
						+ Core.getConfiguration().getConstantValue(REPOSITORY_PATH).toString() + QUOTE + " UserName="
						+ QUOTE + Core.getConfiguration().getConstantValue(EXPORT_USER_PATH).toString() + QUOTE + ">");
		build(builder, "<Version>1.54</Version>");
		build(builder, "<Params>params</Params>");
		build(builder, "<Receivers>");
		build(builder, "<Receiver>ALL</Receiver>");
		build(builder, "</Receivers>");
		build(builder, "</ExportInfo>");
	}

	private void writeProduct(final GenericXML xml, final StringBuilder builder) throws CoreException {
		try {
			final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			final DocumentBuilder dBuilder = factory.newDocumentBuilder();

			final Document document = dBuilder.parse(
					new InputSource(new StringReader(StringHelper.removeInvalidXmlCharacters(xml.getContent()))));
			final NodeList nList = document.getElementsByTagName("Product");

			for (int nodeCount = 0; nodeCount < nList.getLength(); nodeCount++) {
				final Node node = nList.item(nodeCount);
				build(builder, nodeToString(node));
			}
		} catch (final IOException | ParserConfigurationException | SAXException ex) {
			log.error("Error in writeProduct: " + ex.getMessage() + " xml " + xml.getContent() + "journal: "
					+ xml.getGenericXML_Journal().getJournal_ID());
			throw new CoreException(ex.getMessage());
		}
	}

	private void writeSoapFooter(final StringBuilder builder) {
		build(builder, "  </ns2:JFlowExport>");
		build(builder, " </soapenv:Body>");
		build(builder, "</soapenv:Envelope>");
	}

	private File getFile() throws InterruptedException {
		final Random rand = new Random();
		int max = 10000;
		int min = 1;
		String exportDateFileName = new SimpleDateFormat("yyyy-MM-dd HH.mm.ss").format(new Date());
		File file = new File(Core.getConfiguration().getTempPath(), RESULT_NAME + "_" + exportDateFileName + ".xml");
		while (file.exists()) {
			int randomNum = rand.nextInt((max - min) + 1) + min;
			log.debug("Sleeping: " + randomNum);
			Thread.sleep(randomNum);
			log.debug("Retrying create file: " + file.getName());
			exportDateFileName = new SimpleDateFormat("yyyy-MM-dd HH.mm.ss").format(new Date());
			file = new File(Core.getConfiguration().getTempPath(), RESULT_NAME + "_" + exportDateFileName + ".xml");
		}
		return file;
	}

	private void saveGenericXml(final StringBuilder builder, final File file) throws CoreException, Exception {
		final IMendixObject mObj = Core.instantiate(getContext(), ExportedGenericXml.entityName);
		final ExportedGenericXml eXml = ExportedGenericXml.load(getContext(), mObj.getId());
		eXml.setName(file.getName());

		try (final FileInputStream fis = new FileInputStream(file)) {
			byte[] bytesArray = new byte[(int) file.length()];
			int bytesRead = fis.read(bytesArray);
			if (bytesRead != file.length()) {
				throw new IOException("Failed to read entire file");
			}
			Core.storeFileDocumentContent(getContext(), mObj, new ByteArrayInputStream(bytesArray));
		}
		eXml.commit();
	}

	private String exportDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());

	private static final String RESULT_NAME = "JFlowGeneric";

	private static final String QUOTE = "\"";

	private static final String SCHEMA = "http://schemas.xmlsoap.org/soap/envelope/";

	private static final String ENDPOINT_PATH = "Export.Endpoint";

	private static final String MIGRATION_ENDPOINT_PATH = "Export.MigrationEndpoint";

	private static final String USER_PATH = "Export.UserId";

	private static final String MIGRATION_USER_PATH = "Export.MigrationUserId";

	private static final String PW_PATH = "Export.Password";

	private static final String MIGRATION_PW_PATH = "Export.MigrationPassword";

	private static final String REPOSITORY_PATH = "Export.Repository";

	private static final String EXPORT_USER_PATH = "SAPPO_SOAP";

	private static final String GXML_EXPORT4SAP = "GXML4SAP";

	private static final ILogNode log = Core.getLogger("xml");
	// END EXTRA CODE
}
